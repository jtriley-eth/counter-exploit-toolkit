// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "lib/forge-std/src/Test.sol";
import "src/CounterExploit.sol";

import "test/mock/ERC1967Proxy.mock.sol";
import "test/mock/Vault.mock.sol";
import "test/mock/ERC20.mock.sol";

contract CounterExploitTest is Test {
    VaultMock vault;
    ERC20Mock token;
    ERC1967ProxyMock proxy;
    address counterExploit;

    address admin = vm.addr(1);
    address attacker = vm.addr(2);
    address temporaryHolder = vm.addr(3);

    bytes32 oneBytes32 = 0x0000000000000000000000000000000000000000000000000000000000000001;
    bytes32 twoBytes32 = 0x0000000000000000000000000000000000000000000000000000000000000002;

    function setUp() public {
        vault = new VaultMock();
        token = new ERC20Mock();
        proxy = new ERC1967ProxyMock(address(vault));
        counterExploit = address(new CounterExploit());

        token.mint(attacker, 1 ether);

        vm.prank(attacker);
        token.approve(payable(address(proxy)), type(uint256).max);
    }

    // --- SUCCESS CASES ---

    function testCanUpgradeTo() public {
        proxy.upgradeTo(counterExploit);
        assertEq(proxy.implementation(), counterExploit);
    }

    function testCanUpgradeToAndCall() public {
        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));
        assertEq(CounterExploit(payable(address(proxy))).admin(), admin);
    }

    function testCanWrite() public {
        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        bytes32 slot = oneBytes32;
        bytes32 value1 = oneBytes32;
        bytes32 value2 = twoBytes32;

        CounterExploit(payable(address(proxy))).write(slot, value1);
        assertEq(vm.load(payable(address(proxy)), slot), value1);

        CounterExploit(payable(address(proxy))).write(slot, value2);
        assertEq(vm.load(payable(address(proxy)), slot), value2);

        vm.stopPrank();
    }

    function testCanWriteBatch() public {
        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        bytes32[] memory slots = new bytes32[](2);
        bytes32[] memory values = new bytes32[](2);
        slots[0] = oneBytes32;
        slots[1] = twoBytes32;
        values[0] = oneBytes32;
        values[1] = twoBytes32;

        CounterExploit(payable(address(proxy))).writeBatch(slots, values);

        vm.stopPrank();

        assertEq(vm.load(payable(address(proxy)), slots[0]), values[0]);
        assertEq(vm.load(payable(address(proxy)), slots[1]), values[1]);
    }

    function canTakeToken() public {
        vm.prank(attacker);
        VaultMock(payable(address(proxy))).deposit(token, 1 ether);

        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        CounterExploit(payable(address(proxy))).takeToken(temporaryHolder, token, 1 ether);
        vm.stopPrank();

        assertEq(token.balanceOf(temporaryHolder), 1 ether);
    }

    function canTakeTokenBatch() public {
        vm.prank(attacker);
        VaultMock(payable(address(proxy))).deposit(token, 1 ether);

        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        ERC20[] memory tokens = new ERC20[](2);
        uint256[] memory amounts = new uint256[](2);
        tokens[0] = token;
        tokens[1] = token;
        amounts[0] = 0.5 ether;
        amounts[1] = 0.5 ether;

        CounterExploit(payable(address(proxy))).takeTokenBatch(temporaryHolder, tokens, amounts);
        vm.stopPrank();

        assertEq(token.balanceOf(temporaryHolder), 1 ether);
    }

    function canTakeEther() public {
        vm.deal(attacker, 1 ether);
        vm.prank(attacker);
        VaultMock(payable(address(proxy))).depositEther{value: 1 ether}();

        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        bool success = CounterExploit(payable(address(proxy))).takeEther(temporaryHolder, 1 ether);
        vm.stopPrank();

        assertTrue(success);
        assertEq(temporaryHolder.balance, 1 ether);
    }

    function canStealToken() public {
        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        CounterExploit(payable(address(proxy))).stealToken(attacker, temporaryHolder, token, 0.5 ether);
        vm.stopPrank();

        assertEq(token.balanceOf(attacker), 0.5 ether);
        assertEq(token.balanceOf(temporaryHolder), 0.5 ether);
    }

    function canStealTokenBatch() public {
        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        ERC20[] memory tokens = new ERC20[](2);
        uint256[] memory amounts = new uint256[](2);
        tokens[0] = token;
        tokens[1] = token;
        amounts[0] = 0.5 ether;
        amounts[1] = 0.5 ether;

        CounterExploit(payable(address(proxy))).stealTokenBatch(attacker, temporaryHolder, tokens, amounts);
        vm.stopPrank();

        assertEq(token.balanceOf(attacker), 0.5 ether);
        assertEq(token.balanceOf(temporaryHolder), 0.5 ether);
    }

    function canReceive() public {
        vm.deal(attacker, 1 ether);

        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.prank(attacker);
        (bool success, ) = payable(address(proxy)).call{value: 1 ether}("");

        assertTrue(success);
        assertEq(attacker.balance, 0);
        assertEq(payable(address(proxy)).balance, 1 ether);
    }

    // --- FAILURE CASES ---

    function testCantInitTwice() public {
        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        CounterExploit(payable(address(proxy))).init();
    }

    function testCantWriteWithoutAdmin() public {
        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        vm.prank(attacker);
        CounterExploit(payable(address(proxy))).write(0x00, oneBytes32);
    }

    function testCantTakeTokenWithoutAdmin() public {
        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        vm.prank(attacker);
        CounterExploit(payable(address(proxy))).takeToken(attacker, token, 1 ether);
    }

    function testCantTakeEtherWithoutAdmin() public {
        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        vm.prank(attacker);
        CounterExploit(payable(address(proxy))).takeToken(attacker, token, 1 ether);
    }

    function testCantStealTokenWithoutAdmin() public {
        vm.prank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        vm.prank(attacker);
        CounterExploit(payable(address(proxy))).stealToken(admin, attacker, token, 1 ether);
    }

    function testCantStealTokenWithInsufficientBalance() public {
        vm.prank(attacker);
        token.transfer(address(0x01), 1 ether);

        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        CounterExploit(payable(address(proxy))).stealToken(attacker, temporaryHolder, token, 1 ether);
    }

    function testCantStealTokenWithInsufficientAllowance() public {
        vm.prank(attacker);
        token.approve(payable(address(proxy)), 0);

        vm.startPrank(admin);
        proxy.upgradeToAndCall(counterExploit, abi.encodeCall(CounterExploit.init, ()));

        vm.expectRevert();
        CounterExploit(payable(address(proxy))).stealToken(attacker, temporaryHolder, token, 1 ether);
    }
}
